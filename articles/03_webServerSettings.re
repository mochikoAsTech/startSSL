= ウェブサーバの設定をしよう

サーバを立てたらそこにNGINXをインストールします。

ウェブサーバの設定ができたらドメイン名を紐付けて、HTTPでアクセスしてみましょう。

//pagebreak

== サーバにSSHでログインしよう

では立てたばかりのサーバに、SSHでログインしてみましょう。

=== WindowsのRLoginを使ってサーバに入ってみよう

Windowsのパソコンを使っている方は、デスクトップの［rlogin_x64］というフォルダの中にある［RLogin.exe］（@<img>{startRLogin01}）をダブルクリックしてRLoginを起動（@<img>{startRLogin02}）してください。起動したら［新規］をクリックします。

//image[startRLogin01][RLogin.exeをダブルクリック][scale=0.6]{
//}

//image[startRLogin02][RLoginが起動したら［新規］をクリック][scale=0.5]{
//}

初めに［エントリー（上）/コメント（下）］の上に［startSSLInstance］と入力します。続いて［ホスト名（サーバーIPアドレス）］に先ほどメモした［パブリックIPアドレス］を入力（@<img>{startRLogin03}）します。［ログインユーザー名］には［opc］と入力してください。opcというのはOracle Linuxのインスタンスを作成すると、最初から存在しているデフォルトユーザです。

//image[startRLogin03][［ホスト名（サーバーIPアドレス）］と［ログインユーザー名］を入力][scale=0.5]{
//}

次に左メニューで［プロトコル］を選択（@<img>{startRLogin04}）したら、［KeepAliveパケットの送信間隔(sec)］にチェックを入れておきます。これを設定しておくとターミナルをしばらく放っておいても接続が勝手に切れません。続いて［認証キー］をクリックします。

//image[startRLogin04][チェックを入れて［認証キー］をクリック][scale=0.6]{
//}

［認証キー］リストで［startSSLKey］にチェックが入っていることを確認（@<img>{startRLogin05}）します。これは「ログインするときにこの鍵を使います」というリストです。チェックが入っていたら［OK］をクリックして閉じて構いません。

//image[startRLogin05][［startSSLKey］にチェックが入っていることを確認][scale=0.6]{
//}

続いて左メニューで「クリップボード」を選択（@<img>{startRLogin06}）したら、「左クリックの範囲指定だけでクリップボードにコピーする」と「コピー時に範囲指定を解除しない」にチェックを入れて「右クリックでペースト」を選択します。

//image[startRLogin06][右クリックや左クリックの設定][scale=0.6]{
//}

次に左メニューで「フォント」を選択（@<img>{startRLogin07}）したら、文字セットを「UTF-8」に変更します。すべて設定できたら「OK」をクリックしてください。

//image[startRLogin07][文字セットを「UTF-8」に変更][scale=0.6]{
//}

設定が保存できたら「OK」をクリック（@<img>{startRLogin08}）してください。

//image[startRLogin08][設定が保存できたら「OK」をクリック][scale=0.6]{
//}

すると初回のみ、この「公開鍵の確認」が表示（@<img>{startRLogin09}）されます。初回接続時からいきなり中間者攻撃を受けるリスクは低いと判断@<fn>{mitm}して、「接続する」をクリックします。サーバにはそれぞれフィンガープリントという固有の指紋があるため、下部の「この公開鍵を信頼するリストに保存する」にチェックが入っていれば、RLoginが覚えていてくれて、次回以降は「これは過去に信頼したホストの公開鍵と同じだ」と判断してそのまま接続させてくれます。

//footnote[mitm][これは、「このホストの公開鍵を信頼して接続しますか？」と書いてあるとおり、接続先サーバの公開鍵を見せて、「この公開鍵は、本当にあなたが接続したいサーバの公開鍵ですか？中間者攻撃を受けて別のサーバに接続しようとしていないか確認してください」と聞かれています。本来は接続先サーバの公開鍵を、クラウド事業者が提供するシリアル・コンソールなどの別経路で取得し、表示された公開鍵と比較して正当性を確認すべきで、何も確認せずに「接続する」をクリックしてはいけません。ただしここでは、立てたばかりのサーバで初回接続時からいきなり中間者攻撃を受けるリスクは低い、と判断してこの確認を省略しています]

//image[startRLogin09][「公開鍵の確認」が表示されたら「接続する」をクリック][scale=0.4]{
//}

続いて「信頼するホスト鍵のリストを更新しますか？」と聞かれたら「はい」をクリック（@<img>{startRLogin10}）してください。

//image[startRLogin10][「信頼するホスト鍵のリストを更新しますか？」と表示されたら「はい」をクリック][scale=0.4]{
//}

「opc@startsslinstance」と表示（@<img>{startRLogin11}）されたら無事サーバに入れています。SSHでのログイン成功、おめでとうございます！

//image[startRLogin11][「opc@startsslinstance」と表示されたら成功！][scale=0.8]{
//}

もし「opc@startsslinstance」と表示されず、代わりに「SSH2 User Auth Failure "publickey,gssapi-keyex,gssapi-with-mic" Status=1004 Send Disconnect Message... gssapi-with-mic」というようなエラーメッセージが表示（@<img>{startRLogin12}）されてしまったら、これは「鍵がない人は入れないよ！」とお断りされている状態です。［認証キー］リストで［startSSLKey］にチェックが入っていないか、あるいは誤って別の秘密鍵を選択しているものと思われますので、［認証キー］の設定を確認してみてください。

//image[startRLogin12][このエラーが表示されたら［認証キー］を確認しよう][scale=0.4]{
//}

「接続済みの呼び出し先が一定の時間を過ぎても正しく応答しなかったため、接続できませんでした。」というエラーメッセージが表示（@<img>{startRLogin13}）されてしまった場合は、「ホスト名（サーバーIPアドレス）」に書いた「パブリックIPアドレス」が間違っているものと思われます。「ホスト名（サーバーIPアドレス）」のIPアドレスを確認してみてください。

//image[startRLogin13][このエラーが表示されたら「ホスト名（サーバーIPアドレス）」のIPアドレスを確認しよう][scale=0.4]{
//}

=== Macのターミナルを使ってサーバに入ってみよう

Macを使っている方は、ターミナル（@<img>{mac04}）を起動してください。

//image[mac04][最初からインストールされている「ターミナル」を使おう][scale=0.8]{
//}

起動したターミナルで次の文字を入力したらReturnキーを押します。「パブリックIPアドレス」の部分は先ほどメモした「パブリックIPアドレス」に書き換えてください。-iオプションは「サーバにはこの鍵を使って入ります」という意味ですので、「startSSLKey」を保存した場所がデスクトップ以外だった場合はこちらも適宜書き換えてください。

//cmd{
$ ssh opc@パブリックIPアドレス -i ~/Desktop/startSSLKey
//}

初回のみ次のようなメッセージが表示されますが、初回接続時からいきなり中間者攻撃を受けるリスクは低いと判断@<fn>{mitmMac}して、「yes」と打ってReturnキーを押してください。するとMacはちゃんとこのサーバのことを覚えてくれて、次回以降は「これは前に信頼していいって言われたサーバだ！」と判断してそのまま接続させてくれます。

//footnote[mitmMac][詳細は「WindowsのRLoginを使ってサーバに入ってみよう」の注釈で解説しています]
//cmd{
Are you sure you want to continue connecting (yes/no)?
//}

「opc@startsslinstance」と表示されたら無事サーバに入れています。おめでとうございます！

今後はいまやったのと同じやり方をそのまま繰り返せばサーバにログインできます。

== ターミナルでサーバを操作・設定してみよう

ようやくサーバに入れたので、ここからはターミナルの基本的な操作を試してみましょう。

=== プロンプトとは？

では黒い画面で何回かEnterキー（あるいはReturnキー）を押してみましょう。（@<img>{startSSL_63}）普通に改行されますよね。

//image[startSSL_63][Enterキーを押すと改行されて、プロンプトが常に表示されている][scale=0.8]{
//}

このとき左側にずっと出ている次のような表示は「プロンプト」といって、ログインしているユーザ名やサーバの名前などが表示されています。

//cmd{
[opc@startsslinstance ~]$
//}

プロンプトを見るといまは「opc」という一般ユーザであることが分かります。これからサーバに色んな設定をしたいのですが、一般ユーザだと権限がないので「root」という全権限をもったユーザになりましょう。

//cmd{
$ sudo su -
//}

と書いてEnterキーを押すとrootになれます。（@<img>{startSSL_64}）「$」はプロンプトを表していますので入力しないでください。rootになれたらまた何回かEnterキーを押して改行してみましょう。

//image[startSSL_64][sudo su -を書いてEnterキーを押すとrootになれる][scale=0.8]{
//}

いちばん左側に出ているプロンプトが次のように変化しましたか？

//cmd{
[root@startsslinstance ~]# 
//}

ユーザ名が「opc」から「root」に変わりました。それからいちばん右の部分も「$」から「#」に変わっています。プロンプトは@<ttb>{一般ユーザだと「$」で全権を持っているrootだと「#」}という表示になります。今後は「このコマンドをrootで実行してください」のように実行ユーザを詳しく書くことはしませんので、例として書いてある部分のプロンプトが「$」だったらopcのような一般ユーザで実行、「#」だったらrootで実行するんだ、と思ってください。例に「$」や「#」が書いてあってもターミナルで「$」や「#」を自分で入力する必要はありません。

===[column] 【コラム】ターミナルを閉じたいときは？

もう今日の勉強は終わり！サーバとの接続を切ってターミナルを閉じたい、というときはexit（イグジット）というコマンドを叩きます。

//cmd{
# exit
//}

rootになっているときにexitを叩くとopcに戻れます。そしてopcで再びexitを叩くと、サーバの接続を切ってターミナルを閉じることができます。

//cmd{
$ exit
//}

exitをせずに右上の赤い×を押してウィンドウを閉じるのは、電話を切るときに通話オフのボタンを押さずに電話線を引っこ抜くような乱暴な切り方なのでお勧めしません。

===[/column]

== NGINXをインストールしよう

それでは必要なミドルウェアをインストールしていきましょう。最初にrootになっておいてください。インストールするときはyum（ヤム）というコマンドを使います。

//cmd{
$ sudo su -
//}

先ずはyumで色々アップデートしておきましょう。Windowsアップデートみたいなものです。画面にたくさん文字が流れて、少し時間がかかりますが、最後に［Complete!］と表示されたら問題なく完了しています。（@<img>{startSSL_66}）ちなみに-yオプションはYESを意味するオプションです。-yオプションをつけないで実行すると「これとこれを更新するけどいい？ダウンロードサイズとインストールサイズはこれくらいだよ」という確認が表示されて、yと入力してEnterキーを押さないと更新されません。

//cmd{
# yum update -y
//}

//image[startSSL_66][最後に［Complete!］と表示されたらアップデートは完了][scale=0.8]{
//}

続いてNGINX@<fn>{nginxPronounce}を入れます。2020年1月現在の安定バージョン@<fn>{version}である1.16系をインストールしたいので、yumのリポジトリ（どこからNGINXをダウンロードしてくるか）にNGINX公式を追加しましょう。

//footnote[nginxPronounce][NGINXと書いて「えんじんえっくす」と読みます。ウェブサーバのミドルウェアの中でNGINXは順調にシェアを伸ばし、2019年4月にとうとうApacheを抜いてシェア1位になりました。@<href>{https://news.mynavi.jp/article/20190424-813722/}]

//cmd{
# rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm
# cat /etc/yum.repos.d/nginx.repo 

↓以下が表示されればOK
# nginx.repo

[nginx]
name=nginx repo
baseurl=http://nginx.org/packages/centos/7/$basearch/
gpgcheck=0
enabled=1
//}

//footnote[version][サーバに入っているNGINXのバージョンがいくつなのか？という情報は大切です。今後、あなたがNGINXの設定ファイルを書こうと思って調べたとき、例えば1.12系の設定方法を参考にしてしまうと、1.16系のNGINXの環境では上手く動かない可能性があります。]

yumでNGINXをインストールします。

//cmd{
# yum install -y nginx
//}

［Complete!］と表示されたらインストール完了です。バージョン情報を表示することで、ちゃんとインストールされたか確認してみましょう。

//cmd{
# nginx -v
nginx version: nginx/1.16.1　←バージョン情報が表示されればインストールできている
//}

ちょっと分かりにくいかも知れませんが、パソコンにMicrosoft Excelをインストールしたら「表計算というサービスが提供できるパソコン」になるのと同じで、サーバにこのNGINXをインストールすると「リクエストに対してウェブページを返すサービスが提供できるサーバ」、つまりウェブサーバになります。 今回はNGINXを入れましたが、ウェブサーバのミドルウェアは他にもApacheをはじめとして色々な種類があります。

インストールが終わったので、サーバを再起動した場合もNGINXが自動で立ち上がってくるよう、自動起動の設定もオンにしておきましょう。systemctlコマンド@<fn>{systemctlCommand}で、NGINXの自動起動を有効（enable）にします。

//footnote[systemctlCommand][自動起動の設定は、CentOS 6系だとchkconfigコマンドで行なっていましたが、7系ではsystemctlコマンドになっています]

//cmd{
# systemctl enable nginx
# systemctl is-enabled nginx
enabled　←有効になったことを確認
//}

== FirewalldでHTTPとHTTPSを許可しよう

続いてサーバの中で動いているファイアウォールの設定を変更します。まずは現状、何がファイアウォールを通れるようになっているのか確認@<fn>{firewalld}してみましょう。

//cmd{
# firewall-cmd --list-services
dhcpv6-client ssh
//}

//footnote[firewalld][Oracle Linux 7、及びOracle CloudのCentOS 7ではfirewalldがデフォルトで有効化されています。 @<href>{https://docs.oracle.com/cd/E77565_01/E54670/html/ol7-firewalld-cfg.html}]

dhcpv6-clientとsshは通っていいけれど、それ以外は誰であろうと通さないぞ！という設定になっています。このままではブラウザでサイトを見ようとしても、ウェブページを返してくれるはずのNGINXまでリクエストが届きません。そこで次のように、許可対象にhttpとhttpsを追加して、変更が反映されるよう再読み込みします。それぞれ［success］と表示されたら成功しています。

//cmd{
# firewall-cmd --add-service=http --permanent
success

# firewall-cmd --add-service=https --permanent
success

# firewall-cmd --reload
success
//}

これでファイアウォールの設定が変更できたので、もう一度、誰がファイアウォールを通してもらえるのか確認してみましょう。httpとhttpsが追加されていれば問題ありません。

//cmd{
# firewall-cmd --list-services
dhcpv6-client http https ssh
//}

== OSを再起動してみよう

再起動時にNGINXがちゃんと自動起動してくるか確認するため、reboot（リブート）コマンドでサーバを再起動してみましょう。

//cmd{
# reboot
//}

SSHの接続も切れてしまいますが、割とすぐに再起動しますので再度RLoginやターミナルで接続（@<img>{viSelinux06}）してみてください。今度はさっきと同じ設定でそのまま接続できるはずです。

//image[viSelinux06][さっきと同じ設定で接続してみよう][scale=0.8]{
//}

以上で「サーバを立てる」という作業はおしまいです。

=== ターミナルはなんのためにある？

ターミナルでyumやviを叩いてサーバの設定を色々してきましたが、ここで「結局、ターミナルって何なの？」という振り返りをしておきましょう。

@<ttb>{ターミナルはサーバを操作するための画面}です。

皆さんがパソコン使うときはモニタに表示された画面を見ながらキーボードとマウスを使って「フォルダを開いて先週作ったWordファイルを探す」とか「Wordファイルを開いて今週の報告書を書く」というような操作をすると思います。フォルダを開くときは「ダブルクリック」をして、書いた内容を保存するときは「上書き保存する」ボタンを押しますよね。

サーバも同じです。サーバを使うときは「ターミナル」という画面を開いて操作します。ディレクトリ@<fn>{dir}を開いて移動するときはダブルクリックの代わりにcd@<fn>{cd}というコマンドを叩いて移動しますし、ディレクトリの中を見るときもダブルクリックでフォルダを開く代わりにlsコマンドを叩いて見ます。

//footnote[dir][Linuxではフォルダのことをディレクトリと呼びます。]
//footnote[cd][change directoryの略。]

皆さんがいま使っているWindowsやMacといった「パソコン」だったらマウスやキーボードを使ってアイコンやボタンを見ながら操作できますが、サーバは基本的にこの真っ黒な「ターミナル」で文字を打って操作します。パソコンのときはダブルクリックやボタンを押す、という形で伝えていた命令がすべてコマンドに置き換わっていると思ってください。

パソコンもないのにマウスやキーボードだけあっても意味が無いように、ターミナルもそれ単体では何もできません。操作対象であるサーバがあって初めて役に立つ道具なのです。

ちなみにターミナルは背景の色も文字の色も好きに変えられます。どうしても「黒い画面怖い！」という感覚が抜けない人は、ピンクとかオレンジとか好きな色にしてみましょう。@<fn>{color}

//footnote[color][Macのターミナルはそもそも黒じゃなくて白ですね。]

まとめるとターミナルとはサーバを操作するための画面で、操作するときにはコマンドという命令を使います。

== なぜかサイトが見られない

ウェブサーバも立てたし、サーバの中のファイアウォールに穴も空けました。これで準備完了！サーバを立てたときにメモした［パブリックIPアドレス］を、ブラウザで開いてみました。するとしばらくぐるぐるした後で、［接続がタイムアウトしました］と表示されてしまいました。（@<img>{startSSL_77}）

//image[startSSL_77][なぜかHTTPでサイトが表示されない…][scale=0.8]{
//}

403や404や、あるいは502などのステータスコードも返ってきていないので、そもそもNGINXまでたどり着けていないようです。

=== サーバの手前にあるファイアウォールにも穴を空けよう

先ほどサーバの中にあるファイアウォールの設定を変更して、HTTPとHTTPSが通れるようにしましたが、実はサーバの中だけでなく、サーバの外にももう1つファイアウォールがいます。サイトが表示されなかったのは、「ウェブページを見せて！」というリクエストが、サーバの手前のファイアウォールで阻まれていたためなのです。サーバの手前にあるファイアウォールにも穴を空けて、HTTPとHTTPSがサーバまでたどり着けるようにしましょう。

再びOracle Cloudのコンソールに戻って、左上の［ハンバーガーメニュー］から［コンピュート］の［インスタンス］を開きます。（@<img>{startSSL_68}）

//image[startSSL_68][［ハンバーガーメニュー］から［コンピュート］の［インスタンス］を開く][scale=0.8]{
//}

インスタンスの一覧が表示されるので［startSSLInstance］をクリックします。（@<img>{startSSL_69}）

//image[startSSL_69][［startSSLInstance］をクリック][scale=0.8]{
//}

［パブリック・サブネット］をクリックします。（@<img>{startSSL_70}）

//image[startSSL_70][［パブリック・サブネット］をクリック][scale=0.8]{
//}

もう一度、［パブリック・サブネット］をクリックします。（@<img>{startSSL_71}）

//image[startSSL_71][もう一度、［パブリック・サブネット］をクリック][scale=0.8]{
//}

［セキュリティ・リスト］の中にある［Default Security List for VirtualCloudNetwork～］をクリックします。（@<img>{startSSL_72}）このセキュリティ・リストが、サーバの手前にいるファイアウォールです。

//image[startSSL_72][［Default Security List for VirtualCloudNetwork～］をクリック][scale=0.8]{
//}

［イングレス・ルール］で、［イングレス・ルールの追加］をクリックします。（@<img>{startSSL_73}）

//image[startSSL_73][［イングレス・ルールの追加］をクリック][scale=0.8]{
//}

［ソースCIDR］に［0.0.0.0/0］@<fn>{allowFromAll}を入力します。［宛先ポート範囲］には［80,443］@<fn>{portNumber}を入力します。（@<img>{startSSL_74}）どちらも入力できたら、［イングレス・ルールの追加］をクリックします。

//footnote[allowFromAll][ソースCIDRは接続元のIPアドレス範囲のことで、0.0.0.0/0はすべてのIPアドレスを指します。つまり接続元がどんなIPアドレスでもファイアウォールを通れます、ということですね]
//footnote[portNumber][ポート番号とは、サーバという家や、その手前のファイアウォールという壁についているドアのようなものだと思ってください。同じサーバを訪問するときでもSSHは22番のドアを、HTTPは80番のドアを、HTTPSは443番のドアを通ります]

//image[startSSL_74][［ソースCIDR］に［0.0.0.0/0］、［宛先ポート範囲］には［80,443］を入力][scale=0.8]{
//}

［イングレス・ルール］に、HTTP（80番ポート）とHTTPS（443番ポート）へのリクエストを通す設定が追加されました。（@<img>{startSSL_75}）

//image[startSSL_75][ルールが追加された！][scale=0.8]{
//}

=== 今度こそHTTPでサイトを見てみよう

再び、サーバを立てたときにメモした［パブリックIPアドレス］を、ブラウザで開いてみましょう。（@<img>{startSSL_76}）

//image[startSSL_76][HTTPでサイトが見られた！][scale=0.8]{
//}

［Welcome to nginx!］と表示されました！これでまず、「HTTPでサイトを表示する」はクリアです。

== ドメイン名の設定をしよう

ウェブサーバの準備ができたので、HTTPSのサイト用にドメイン名を用意します。「自分のドメイン名？そんなの持ってないよ！」という人は、先に「DNSをはじめよう」@<fn>{booth}で、ドメイン名を買ってからこの先へ進むようにしてください。

//footnote[booth][@<href>{https://mochikoastech.booth.pm/}]

あなたが買ったドメイン名を使って「ssl.自分のドメイン名」のAレコードを作成して、サーバの［パブリックIPアドレス］と紐付けてください。ネームサーバはお名前.comを使用してもいいですし、AWSのRoute53で設定しても構いません。

なお筆者が「DNSをはじめよう」で購入したのは@<code>{startdns.fun}というドメイン名だったので、@<code>{ssl.startdns.fun}というAレコードを作って、さっき立てたばかりのサーバの［パブリックIPアドレス］と紐付けます。例えばネームサーバが「お名前.com」なら、DNS設定の画面でこのようにAレコードを追加します。（@<img>{onamaeARR}）

//image[onamaeARR][「ssl.自分のドメイン名」のAレコードを作成する][scale=0.6]{
//}

Aレコードを追加できたかどうかは、次のdigコマンドで確認できます。digコマンドをたたいた結果、サーバのIPアドレスが返ってくればAレコードは設定できています。

//cmd{
$ dig ssl.自分のドメイン名 a +short
//}

筆者の場合は、次のように表示されました。

//cmd{
$ dig ssl.startdns.fun a +short
140.238.33.51
//}

ドメイン名が設定できたら、ブラウザでも「http://ssl.自分のドメイン名」を叩いてみましょう。先ほどと同じNGINXのページが表示されるはずです。（@<img>{startSSL_78}）

//image[startSSL_78][「ssl.自分のドメイン名」でサイトが表示された！][scale=0.8]{
//}

HTTPでサイトを見ることができましたが、同じドメイン名をHTTPSで開いてみるとどうでしょう？ブラウザで「https://ssl.自分のドメイン名」を開いてみると、［正常に接続できませんでした］と表示（@<img>{startSSL_85}）されました。

//image[startSSL_85][HTTPSで開くと［正常に接続できませんでした］と表示された][scale=0.8]{
//}

それではHTTPSでもサイトが見られるように、次章でSSL証明書を取得して、設定を進めていきましょう。
